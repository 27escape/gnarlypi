#!/usr/bin/env python3

import os
import re
import sys
import time
import psutil
import shutil
import signal
import argparse
import threading
import subprocess
from stat import *
from dotwiz import DotWiz

sys.path.insert(0, "../")
from libs.status import Status
from libs.messaging import Messaging
from libs.locking import Lock
from libs.config import Config
from libs.debug import Debug

VERSION = "0.2.0"
APP_NAME = os.path.basename(__file__) + " v" + VERSION
CREATOR = "27escape"
COPYRIGHT = "©️2025"

# get config from default location $GNARLYPI_CONFIG
config = Config()
logger = Debug( APP_NAME, config.get("gnarlypi.logfile"), config.get("gnarlypi.loglevel", "none"))

# ----------------------------------------------------------------------------

ONE_MB = 1024 * 1024
READ_SIZE = 16 * ONE_MB
# time between checks for card mounted
WAIT_TIME = 1

# ----------------------------------------------------------------------------

DISK_BY_LABEL = "/dev/disk/by-label"
USER = os.getenv("USER")
HOME = os.getenv("HOME")

# Replace with your desired destination directory
TARGET_DIR = ""
INDEX_DIR = ""
FILES_DIR = ""
last_mount = ""

status = None

copy_status = DotWiz({"in_copy_process": False, "copy_abandon": False})
startup_devices = []

def print_error(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

# ----------------------------------------------------------------------------


def signal_handler(sig, frame):
    """ """

    logger.info("You pressed Ctrl+C!")
    if len(last_mount):
        umount_drive(last_mount)

    status.fivelines(("", APP_NAME, "", "offline", ""))
    sys.exit(0)


signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGHUP, signal_handler)


# ----------------------------------------------------------------------------

def get_rpi_model():
    """Get the Raspberry Pi hardware model. Return None if not a Pi."""
    try:
        with open('/proc/cpuinfo', 'r') as f:
            for line in f:
                if line.startswith('Model'):
                    model = line.strip().split(':')[1].strip()
                    return model
    except FileNotFoundError:
        logger.error("Could not read /proc/cpuinfo. Are you running on a Raspberry Pi?")
        return None


def is_zero():
    """Check if the Raspberry Pi is a Zero model."""
    model = get_rpi_model()
    if model and 'Zero' in model:
        return True
    return False


# ----------------------------------------------------------------------------
def is_program_running(program_name, kill=False):
    """
    Check if a program is already running and optionally kill it.

    Args:
        program_name (str): The name of the program to check.
        kill (bool): If True, kill the running process.

    Returns:
        bool: True if the program is running, False otherwise.
    """
    for proc in psutil.process_iter(["pid", "name"]):
        try:
            if program_name.lower() in proc.info["name"].lower():
                if kill:
                    proc.kill()
                    logger.info(
                        f"Killed process {proc.info['name']} with PID {proc.info['pid']}"
                    )
                    return False
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    return False


# ----------------------------------------------------------------------------
# wait for some time but send keep alives
def wait_time(sleeptime):
    count = 0
    while True:
        status.keepalive()
        time.sleep(1)
        count += 1
        if count >= sleeptime:
            break


# ----------------------------------------------------------------------------
def wait_forever( msg1, level, msg2=""):
    while True:
        status.error(msg1, level, msg2)
        wait_time( 1)

# ----------------------------------------------------------------------------
def check_freespace(target, required):
    while True:
        total, used, free = shutil.disk_usage(os.path.dirname(target))
        if free > required:
            break
        else:
            status.diskfull()
            logger.error(f"cannot store {target}, device is full")
            wait_forever( "disk full", 1, "remove files")


# ----------------------------------------------------------------------------
def update_drive_stats():
    # shutil.disk_usage should be in bytes but I think its in KBs
    hd_total, hd_used, hd_free = shutil.disk_usage(TARGET_DIR)
    if last_mount:
        sd_total, sd_used, sd_free = shutil.disk_usage(last_mount)
    else:
        sd_total = 0
        sd_free = 0
    status.devicedata(sd_total, sd_free, hd_total, hd_free)


# ----------------------------------------------------------------------------


def copy_file(src_path, dst_path, force=False, copy_stats={"copied": 0, "total": 0}):
    """
    Copies a file from source to destination, checking existence, size, and modification time.

    Args:
        src_path: Path to the source file.
        dst_path: Path to the destination file.
        force: force the overwrite of an existing destination file, default False

    Returns:
        True if the file is copied successfully or already exists, False otherwise.
    """
    # Check if source file exists
    if not os.path.isfile(src_path):
        logger.warning(f"Error: Source file '{src_path}' does not exist.")
        return False

    # Get source file stats
    src_stat = os.stat(src_path)
    # Check if destination file exists
    if not force and os.path.exists(dst_path):
        # Check if destination is a regular file
        if not S_ISREG(src_stat.st_mode):
            logger.error(f"Error: Destination '{dst_path}' is not a regular file.")
            return False

        # if mtime and file size match, assume same file
        if src_stat.st_mtime == os.stat(
            dst_path
        ).st_mtime and src_stat.st_size == os.path.getsize(dst_path):
            logger.debug(f"skipping copy {src_path} as {dst_path}, already exists")    
            return False

    logger.debug(f"copy {src_path} to {dst_path} with force as {force}")
    # use a temp file in case of failure, so would not overwrite an existing file
    tmpdest = f"{dst_path}.tmp"
    # Copy the file
    try:
        copied = 0
        total = src_stat.st_size

        # will return if there is enough space, assumed to be 1.5 of file size
        check_freespace(dst_path, int(total * 1.5))

        with open(src_path, "rb") as f_in, open(tmpdest, "wb") as f_out:
            status.copydata(
                src_path,
                dst_path,
                total,
                copied,
                copy_stats["copied"],
                copy_stats["total"],
            )

            while chunk := f_in.read(READ_SIZE):
                f_out.write(chunk)  
                copied += len(chunk)
                status.copydata(
                    src_path,
                    dst_path,
                    total,
                    copied,
                    copy_stats["copied"],
                    copy_stats["total"],
                )

        # move to dst_path to make it atomic
        os.rename(tmpdest, dst_path)
        # Set destination file modification time
        os.utime(dst_path, (src_stat.st_mtime, src_stat.st_mtime))
        status.indexfile(dst_path)

        logger.debug(f"{src_path} -> {dst_path}")
    except Exception as e:
        # remove any part copied file
        os.remove(tmpdest)
        logger.error(f"Error copying file: {e}")
        update_drive_stats()
        return False

    update_drive_stats()
    return True


# ----------------------------------------------------------------------------


def rCopy(src, dst, force):
    """
    Recursively copies files from source directory to destination directory.

    Args:
      src: Source directory path.
      dst: Destination directory path.
      total_files: Total number of files to be copied (optional).
    """
    copied = 0
    fails = 0
    total = 0
    logger.info(f"copying files from {src} to {dst} with force {force}")

    update_drive_stats()
    # count files that we need to copy
    for dirpath, dirnames, filenames in os.walk(src):
        for filename in filenames:
            src_path = os.path.join(dirpath, filename)
            dst_path = os.path.join(dst, os.path.relpath(src_path, src))
            if force or not os.path.exists(dst_path):
                total += 1

    status.startcopy(file_count=total)

    for dirpath, dirnames, filenames in os.walk(src):
        # if not wantAbandon():
        for filename in filenames:
            src_path = os.path.join(dirpath, filename)
            dst_path = os.path.join(dst, os.path.relpath(src_path, src))
            # Create destination directory structure if needed
            os.makedirs(os.path.dirname(dst_path), exist_ok=True)
            update = 0
            if force or not os.path.exists(dst_path):
                update = 1

            if copy_file(
                src_path,
                dst_path,
                force,
                copy_stats={"copied": copied, "total": total},
            ):
                # only update the copy count if there was a file to copy
                copied += update
                logger.debug(f"({copied}/{total})")
            else:
                fails += 1
                # if wantAbandon():
                #     logger.info("abandon copying")
                #     break
    if fails:
        logger.error(f"failed to copy {fails} files in {total}")
    logger.debug(f"total ({copied}/{total})")
    update_drive_stats()
    status.indextrip()
    status.endcopy(files_copied=copied, file_count=total)


# ----------------------------------------------------------------------------


def mount_drive(device_path, mount):
    """
    Attempts to mount the USB drive at device_path to mount_point.
    """
    global last_mount
    mounted = False
    try:
        logger.info(f"mounting {device_path}  to {mount}")
        subprocess.run(["sudo", "mount", device_path, mount])
        logger.debug(f"{device_path} drive mounted at {mount}")
        last_mount = mount
        mounted = True
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to mount drive: {e}")
    return mounted


# ----------------------------------------------------------------------------
def umount_drive(mount):
    """ """
    global last_mount

    try:
        if os.path.ismount(mount):
            # lazy force umount
            subprocess.run(["sudo", "umount", "-l", mount])
            if not os.path.ismount(mount):
                logger.debug(f"unmounted {mount}")
                last_mount = ""
                # remove the mount point to keep the drive tidy, no other reason
                os.rmdir(mount)
            else:
                logger.error("unmount failed")

    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to umount drive: {e}")


# ----------------------------------------------------------------------------


def make_dest(dest):
    """
    make destination directory set ownership to that of parent directory
    """
    try: 
        logger.debug(f"making {dest} if needed")
        os.makedirs(dest, exist_ok=True)
        parent = os.path.dirname(dest)
        stat = os.stat(parent)
        os.chown(dest, stat.st_uid, stat.st_gid)
    except Exception as e:
        logger.error(f"Failed to make destination {dest}: {e}")
        wait_forever("cannot make dir", 4, "check logs")

# ----------------------------------------------------------------------------
# find attached devices
def getDevices():
    """Runs the lsblk command and returns the output as a list of lines."""
    devices = []

    try:
        output = subprocess.check_output(["lsblk", "-ln"], text=True)
        for dev in output.splitlines():
            parts = dev.split()
            # there must be a partition number
            if re.match(r".*\d$", parts[0]):
                # there may be a nicer way to represent this conditional
                # but for now, it works and is readable
                if parts[5] == "part":
                    if len(parts) != 7:
                        # currently unmounted so assume OK
                        devices.append("/dev/" + parts[0])
                    else:
                        tmpname = "/dev/" + parts[0]
                        # on first run this will be empty, but filled at the start of main
                        # we want to ignore any devices that were pre-mounted, as one of
                        # these may be the storage device we want to copy to
                        # if parts[6] not in startup_devices:
                        # if not any(parts[6] in device for device in startup_devices):
                        if tmpname not in startup_devices:
                            devices.append(tmpname)

    except subprocess.CalledProcessError as e:
        print(f"Error running lsblk: {e}")

    return devices


# ----------------------------------------------------------------------------
# loop with a small delay until all devices are no longer registered
def wait_remove_all_devices():
    update_drive_stats()
    status.waitremove()
    while True:
        devices = getDevices()
        if not len(devices):
            break
        wait_time(1)


# ----------------------------------------------------------------------------


def copyFromDevice(device, useTheForce):
    """Copy all suitable files from the named device
    mount the device, copy the files, unmount the device
    """
    # Get list of currently mounted devices under /dev/disk/by-label
    mount_point = os.path.join(HOME, "mounts", os.path.basename(device))
    if not os.path.exists(mount_point):
        make_dest(mount_point)

    # Check if device isn't already mounted
    if not os.path.ismount(mount_point):
        if mount_drive(device, mount_point):
            camera_dir = os.path.join(mount_point, "DCIM")
            # test if we have a camera related folder structure
            # Copy files only if its a photo drive
            if os.path.isdir(camera_dir):
                # and we only copy the DCIM files
                rCopy(camera_dir, FILES_DIR, useTheForce)
            else:
                logger.debug("drive does not contain photo files")
            # Unmount the drive
            update_drive_stats()
            umount_drive(mount_point)
        else:
            logger.error(f"could not mount {device} to {mount_point}")
            status.error("mount fail", 5, "remove device")
            time.sleep(60)
    else:
        logger.warning(f"no mount point {mount_point}")


# ----------------------------------------------------------------------------
def wait_drive_inserted():
    status.ready("Insert SD card")
    while True:
        update_drive_stats()

        devices = getDevices()
        if len(devices) != 0:
            break
        wait_time(1)


# ----------------------------------------------------------------------------
# thread to listen for button press messages
msg = Messaging()


# ----------------------------------------------------------------------------
# start the status apps, assumes we are in bin dir
def start_status_apps():
    apps = config.get("status.devices")
    if apps and len(apps) != 0:
        for app in apps:
            if not is_program_running(app, True):
                logger.info(f"starting {app}")
                #   ensure environment is passed to the new process
                env = os.environ.copy()
                subprocess.Popen([os.path.join("..", "status", app)], env=env)

    # give them a sec to start and settle
    time.sleep(1)


# ----------------------------------------------------------------------------
# the apps currently are the photo indexer and the rsync
def start_apps():
    apps = config.get("gnarlypi.apps")
    if apps and len(apps) != 0:
        for app in apps:
            if not is_program_running(app, True):
                logger.info(f"starting {app}")
                env = os.environ.copy()
                subprocess.Popen([os.path.join("..", "bin", app)], env=env)


# ----------------------------------------------------------------------------
# pretty standard daemonise function
def daemonise():
    # Perform the first fork
    if os.fork() > 0:
        sys.exit()

    # Decouple from parent environment
    os.chdir("/")
    os.setsid()
    os.umask(0)

    # Perform the second fork
    if os.fork() > 0:
        sys.exit()

    # Redirect standard file descriptors
    sys.stdout.flush()
    sys.stderr.flush()
    with open(os.devnull, "r") as devnull:
        os.dup2(devnull.fileno(), sys.stdin.fileno())
    with open(os.devnull, "a+") as devnull:
        os.dup2(devnull.fileno(), sys.stdout.fileno())
        os.dup2(devnull.fileno(), sys.stderr.fileno())

# ----------------------------------------------------------------------------

if __name__ == "__main__":

    if USER == "root":
        logger.info(
            f"Do not run this script as root, run is as one of your users, give a user permisison to mount drives with this command:  sudo usermod -aG disk {os.getenv('SUDO_USER')}"
        )
        sys.exit(1)

    try:

        status = Status()
        TARGET_DIR = config.get("gnarlypi.store")
        FILES_DIR = os.path.join(TARGET_DIR, "files")
        INDEX_DIR = os.path.join(TARGET_DIR, "index")

        parser = argparse.ArgumentParser(
            description=f"Watch for USB drive insertions and copy any photo files from them to {TARGET_DIR}, change this in config file"
        )
        args = parser.parse_args()

        start_status_apps()

        if not TARGET_DIR or not len(TARGET_DIR):
            logger.error(f"Missing photo dir ${TARGET_DIR}")
            wait_forever("Missing photo dir", 2, "Fix and reboot")
            
        make_dest(TARGET_DIR)

        if not os.path.isdir(TARGET_DIR):
            logger.error(f"Bad TARGET dir ${TARGET_DIR}")
            wait_forever("Bad photo dir", 3, "Fix and reboot")

        logger.info(f"Using photo dir {TARGET_DIR}")

        pause_time = 1
        if is_zero():
            logger.info("Running on a Pi Zero")
            # time to let things settle and the user see the copyright message
            pause_time = 3
        time.sleep( pause_time)

        status.fivelines((APP_NAME, "", CREATOR, COPYRIGHT, ""))

        start_apps()
        daemonise()
        wait_time(3)

        # get the list of devices already mounted at startup
        # so we can ignore them later
        startup_devices = getDevices()
        logger.info(f"startup devices {startup_devices}")

        status.clear()

        # main thread performing file copies
        # Loop to continuously monitor for USB drives
    
        while True:

            update_drive_stats()
            wait_drive_inserted()
            
            # only aquire the lock when we are ready to copy
            lock = Lock()
            logger.debug("waiting for lock")
            lock.waitLock()
            logger.debug("got lock")

            # Get list of devices via blkid
            for device in getDevices():
                # if not wantAbandon():
                copyFromDevice(device, config.get("gnarlypi.force"))

            wait_remove_all_devices()
            lock.releaseLock()
            logger.debug( "released lock")
            

    except Exception as e:
        logger.error(f"Error: {e}")
        print(f"Error: {e}")
        sys.exit(1)        
