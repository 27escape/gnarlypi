#!/usr/bin/env python3

import os
import re
import sys
import time
import signal
import argparse
import contextlib
import subprocess
from dotwiz import DotWiz

sys.path.insert( 0, '../')
from libs.status import Status
from libs.locking import Lock
from libs.config import Config
from libs.debug import Debug
# ----------------------------------------------------------------------------

USER = os.getenv("USER")
HOME = os.getenv("HOME")
APP_NAME = os.path.basename(__file__)

# get config from default location $GNARLYPI_CONFIG
config = Config()
logger = Debug( APP_NAME, config.get("gnarlypi.logfile"), config.get("gnarlypi.loglevel", "none"))

copy_status = DotWiz( { "in_copy_process": False, "copy_abandon": False})


# ----------------------------------------------------------------------------


def signal_handler(sig, frame):
    """ """
    logger.info(f"Exit requested for {APP_NAME} by signal {sig}")
    sys.exit(1)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGHUP, signal_handler)

# ----------------------------------------------------------------------------
# taken from https://stackoverflow.com/questions/803265/getting-realtime-output-using-subprocess
# Unix, Windows and old Macintosh end-of-line
newlines = ['\n', '\r\n', '\r']
def unbuffered(proc, stream='stdout'):
    stream = getattr(proc, stream)
    with contextlib.closing(stream):
        while True:
            out = []
            last = stream.read(1)
            # Don't loop forever
            if last == '' and proc.poll() is not None:
                break
            while last not in newlines:
                # Don't loop forever
                if last == '' and proc.poll() is not None:
                    break
                out.append(last)
                last = stream.read(1)
            out = ''.join(out)
            yield out


# ----------------------------------------------------------------------------

def run_rsync_with_progress(source, destination):
    """Runs the rsync command and parses the progress output.

    Args:
        source: The source directory to be backed up.
        destination: The destination directory for the backup.

    """

    status.clear()

    try:
        current_file = ""
        filesize = 0
        left = 0
        total = 0

        # leinfo.sav is a file that is created by gopro's, we don't want to copy it
        # we also want symlinks such as those creaed by the index to be copied as files
        rsync_cmd = ["rsync", "-raviP", "--progress", "--no-inc-recursive", "--exclude='.DS_store'", "--exclude='leinfo.sav'", "--copy-links", source, destination]
        logger.info( f"running [{' '.join( rsync_cmd)}]")

        # universal_newlines -  Make all end-of-lines '\n'
        # this means we will also get line updates during copy process that would have ended with \r
        # also assumes output is text
        proc = subprocess.Popen(rsync_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)

        while proc.poll() is None:
            # if wantAbandon():
            #   raise Exception( 'Abandon required')

            # line = proc.stdout.readline().decode("utf-8").strip()
            line = proc.stdout.readline().strip()
            # logger.info( line)
            if file_match := re.search(r"^.f.*?\s(.*)$", line):
                current_file = os.path.join( os.path.dirname(source), file_match.group(1))
                logger.info( f"{total - left}/{total}  {current_file}")
                filesize = os.path.getsize( current_file)
                # log when we have a file, it may take some time to copy if remote
                status.copydata(
                  current_file,
                  current_file,
                  0,
                  filesize,
                  (total - left),
                  total,
                  0,
                  True
                )

            # catch updates to file copy stats
            elif count_match := re.search(r"([0-9,]+).*?%\s+(.*?)B\/s\s+", line):
              # check end of file copy info
                bytes_copied = int(count_match.group(1).replace(',', ''))
                bps = 0
                bps_str = count_match.group(2)
                bps_orig = bps_str

                # find file counts, this happens when the file is complete
                if end_match := re.search(r"to-chk\=([0-9]+)\/([0-9]+)", line):
                  # the number of files known that are still around to process
                  left = int(end_match.group(1))
                  # total is a combination of files and dirs locally
                  # we are really only using it as a guide
                  total = int(end_match.group(2))

                if bps_str.endswith( "M"):
                  bps_str = float(bps_str[:-1])
                  bps = bps_str * 1024 * 1024
                elif bps_str.endswith( "K") or bps_str.endswith( "k"):
                  bps_str = float(bps_str[:-1])
                  bps = bps_str * 1024
                else:
                  bps = bps_str
                # if we need more detail
                logger.debug( f"  {bps_orig} {current_file}")
                status.copydata(
                  current_file,
                  current_file,
                  filesize,
                  bytes_copied,
                  (total - left),
                  total,
                  int(bps),
                  True
                )
                
        if total:
          logger.info( f"backed up {total} files/folders")

        # let the user know things have been copied 
        if total:
          status.fivelines(( "", "Completed", "", f"{total} files", ""))
          time.sleep(5)
          status.fivelines(( "", "", "", "", ""))


    except subprocess.CalledProcessError as e:
        print(f"Error running rsync: {e}")
        return 0, 0


# ----------------------------------------------------------------------------

if __name__ == "__main__":

    if USER == "root":
        logger.info("Do not run this script as root")
        sys.exit(2)

    try:

      source = config.get('rsync.source').replace("//", "/")
      target = config.get('rsync.target')

      parser = argparse.ArgumentParser(
          description=f"Copy backed up photos from {source} to a {target} using rsync, change values in config file"
      )    
      args = parser.parse_args()

      # Check if source dierctory exists
      if not os.path.exists(source) or not os.path.isdir( source):
          logger.info(f"Error: Source '{source}' is not a directory.")
          print(f"Error: Source '{source}' is not a directory.")
          sys.exit(3)
      
      status = Status()
      
      while True:
        # default to 10 mins
        time.sleep( int(config.get('rsync.sleep', 600)))

        lock = Lock()

        # we cannot check the target, this will be down to the user
        logger.debug( "rsync waitlock")
        lock.waitLock()
        logger.debug("rsync got lock")
        status.ready("running rsync...")
        run_rsync_with_progress(source, target)
        lock.releaseLock()
        logger.debug( "rsync released lock")
        status.ready("INSERT SD CARD")
        
    except Exception as e:
      logger.error(f"Error: {e}")
      print(f"Error: {e}")
      sys.exit(1)
